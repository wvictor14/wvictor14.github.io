---
title: '"Can you check gene x for me?" quickly reading 1 gene at a time from single cell data'
author: Victor Yuan
date: '2024-02-24'
slug: read-1-gene-from-single-cell
categories:
  - R
  - Analysis
  - scRNAseq
tags:
  - Bioconductor
  - R
  - scRNAseq
  - Analysis
subtitle: ''
summary: ''
authors: []
lastmod: '2024-02-24T11:30:22-08:00'
featured: no
draft: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
editor_options: 
  chunk_output_type: console
---



<p>“Can you check gene x for me?” is a common question I get when working with other scientists on gene expression projects. This is an easy task after setting up a gene expression web apps with shiny. Though, one pain point for specficially single cell data is that app start up and general data queries become quite slow if using standard analytical single cell packages like <code>Seurat</code> and others. For example, a 500 000 cell dataset can take up to 40 seconds to load into memory. Increasingly, I need to check a gene in not just one, but multiple single cell datasets. In my current system of loading entire single cell datasets into memory, this is terribly inefficient for what is essentially a simple task.</p>
<p>How can we optimize these queries so that instead of taking minutes, it only takes seconds?</p>
<p>Well, rather than loading the entire data into memory, can we load only the relevant portion, i.e. a gene of interest?</p>
<div id="single-cell-formats" class="section level1">
<h1>Single cell formats</h1>
<p>If we distill this task into a more general one - loading a single row / slice from rectangular data, then there are many options that exist. However, for single cell RNAseq data there are other considerations:</p>
<ul>
<li><p>data for single cell is often the order of 20,000 - 40,000 genes, often arranged in rows, and 100 000 - 1 million cells in the columns. It does not often travel in “tidy” formats (e.g. with columns gene, cell, value).</p></li>
<li><p>single cell count matrix usually travels as sparse matrix due to high drop-out rate. Coercion to dense is resource-heavy so need to do this thoughtfully and only when necessary.</p></li>
</ul>
<p>For this post I explore how to utilize the HDF5 format to speed up reading 1 gene at a time into R, in order to address memory and speed issues when working with large and multple single cell datasets.</p>
</div>
<div id="options-for-using-hdf5-with-single-cell-data" class="section level1">
<h1>Options for using HDF5 with single cell data</h1>
<p>Actually, there is already a great memory-efficient solution out there called <a href="https://github.com/SGDDNB/ShinyCell">ShinyCell</a>, which utilizes the HDF5 format, and produces a clean, fast, memory-efficient shiny-based app. It looks like <code>ShinyCell</code> has it’s own approach to writing single cell count data to h5 format.
I think this is interesting because there are already some existing h5 formats already designed for single cell data, like python’s <code>.h5ad</code> and <code>h5Seurat</code>. And in contrast to these ones, <code>Shinycell</code> writes a dense count matrix, rather than the other formats mentioned which keep the format of the data as sparse. This makes sense though as the goal of these other formats is to provide entry to existing tools that work with sparse data.</p>
<p>So I will compare <code>ShinyCell</code>’s rather manual h5 strategy to some other options. The other option included here is <code>HDF5Array</code> + <code>delayedArray</code>, which are some Bioconductor options specifically for Bioconductor-specific data structures, like scRNAseq.</p>
</div>
<div id="key-packages-for-this-post" class="section level1">
<h1>Key packages for this post</h1>
<p>For HDF5, there are a couple of general purpose options in R: <a href="https://cran.r-project.org/web/packages/hdf5r/index.html">hdf5r</a>, <a href="https://bioconductor.org/packages/release/bioc/html/rhdf5.html">rhdf5</a>. Then there is the bioconductor package <a href="https://bioconductor.org/packages/release/bioc/html/HDF5Array.html">HDF5Array</a> which uses <code>hdf5r</code> in backend to work with bioconductor data structures specifically.</p>
</div>
<div id="other-packages" class="section level1">
<h1>Other packages</h1>
<p><code>HDF5Array</code> hdf5 read write dense/sparse matrices
<code>hdf5r</code> hdf5 r implementation
<code>scRNAseq</code> to access example scRNAseq dataset
<code>tidyverse</code> <code>glue</code> <code>gt</code> <code>fs</code> general purpose
<code>tictoc</code> <code>bench</code> timing</p>
<pre class="r"><code>library(HDF5Array)
library(hdf5r)
library(scRNAseq)
library(tidyverse)
library(tictoc)
library(withr)
library(bench)
library(gt)
library(glue)
library(fs)</code></pre>
<pre class="r"><code>sce &lt;- ZilionisLungData()</code></pre>
<pre><code>## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation</code></pre>
<pre><code>## loading from cache</code></pre>
<pre><code>## see ?scRNAseq and browseVignettes(&#39;scRNAseq&#39;) for documentation</code></pre>
<pre><code>## loading from cache</code></pre>
<pre class="r"><code>counts &lt;- sce@assays@data$counts[,]</code></pre>
</div>
<div id="saving-dgc-matrix-manually-with-hdf5r" class="section level1">
<h1>Saving dgc matrix manually with hdf5r</h1>
<p>This is ShinyCell’s approach, which is to write the sparse count matrix of a <code>Seurat</code> / <code>SingleCellExperiment</code> object to a dense representation on disk. Because converting the sparse matrix to dense would implode most computers, shinycell’s approach is to do this in chunks / loops.</p>
<p>I modify the code to make it easier to follow, and I litter the function with <code>tictoc::tic</code> and <code>toc</code> to monitor the overall and each step takes.</p>
<p>Alternatively, we could write sparse representation to disk, which would be faster to write (less data), but then we would need to convert to dense on the read-in endpoints. I don’t do that here, because the goal is to speed up read-in, not write-out. Though it may be trivially fast to coerce a 1 x 1million vector? Am not sure.</p>
<pre class="r"><code>file_h5 &lt;- fs::path(&#39;counts.h5&#39;)
if (file.exists(file_h5)) file.remove(file_h5)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>write_dgc_to_h5 &lt;- function(dgc, file, chunk_size = 500) {
  
  # open h5 connection and groups
  h5 &lt;- H5File$new(file, mode = &quot;w&quot;)
  on.exit(h5$close_all())
  h5_grp &lt;- h5$create_group(&quot;grp&quot;)
  h5_grp_data &lt;- h5_grp$create_dataset(
    &quot;data&quot;,  
    dtype = h5types$H5T_NATIVE_FLOAT,
    space = H5S$new(&quot;simple&quot;, dims = dim(dgc), maxdims = dim(dgc)),
    chunk_dims = c(1, ncol(dgc))
  )
  
  tic(&#39;total&#39;)
  for (i in 1:floor((nrow(dgc) - 8)/chunk_size)) {
    
    index_start &lt;- ((i - 1) * chunk_size) + 1
    index_end &lt;- i * chunk_size
    tic(glue::glue(&#39;loop {i}, rows {index_start}:{index_end}&#39;))
    
    h5_grp_data[index_start:index_end, ] &lt;- dgc[index_start:index_end,] |&gt; 
      as.matrix()
    toc(log = TRUE)
  }
  
  # final group
  index_start &lt;- i*chunk_size + 1
  index_end &lt;- nrow(dgc)
  
  tic(glue::glue(&#39;final loop, rows {index_start}:{index_end}&#39;))
  h5_grp_data[index_start:index_end, ] &lt;- as.matrix(dgc[index_start:index_end, ])
  toc(log = TRUE)
  
  # add rownames and colnames
  h5_grp[[&#39;rownames&#39;]] &lt;- rownames(dgc)
  h5_grp[[&#39;colnames&#39;]] &lt;- colnames(dgc)
  toc()
}
write_dgc_to_h5(counts, file_h5, chunk_size = 1000)</code></pre>
<pre><code>## loop 1, rows 1:1000: 7.81 sec elapsed
## loop 2, rows 1001:2000: 7.06 sec elapsed
## loop 3, rows 2001:3000: 7.02 sec elapsed
## loop 4, rows 3001:4000: 6.97 sec elapsed
## loop 5, rows 4001:5000: 8.73 sec elapsed
## loop 6, rows 5001:6000: 6.5 sec elapsed
## loop 7, rows 6001:7000: 7.19 sec elapsed
## loop 8, rows 7001:8000: 6.92 sec elapsed
## loop 9, rows 8001:9000: 6.84 sec elapsed
## loop 10, rows 9001:10000: 6.58 sec elapsed
## loop 11, rows 10001:11000: 6.41 sec elapsed
## loop 12, rows 11001:12000: 6.78 sec elapsed
## loop 13, rows 12001:13000: 6.39 sec elapsed
## loop 14, rows 13001:14000: 7.28 sec elapsed
## loop 15, rows 14001:15000: 6.33 sec elapsed
## loop 16, rows 15001:16000: 6.67 sec elapsed
## loop 17, rows 16001:17000: 6.83 sec elapsed
## loop 18, rows 17001:18000: 7.31 sec elapsed
## loop 19, rows 18001:19000: 6.39 sec elapsed
## loop 20, rows 19001:20000: 6.67 sec elapsed
## loop 21, rows 20001:21000: 6.86 sec elapsed
## loop 22, rows 21001:22000: 7.36 sec elapsed
## loop 23, rows 22001:23000: 6.38 sec elapsed
## loop 24, rows 23001:24000: 6.75 sec elapsed
## loop 25, rows 24001:25000: 6.78 sec elapsed
## loop 26, rows 25001:26000: 7.09 sec elapsed
## loop 27, rows 26001:27000: 6.14 sec elapsed
## loop 28, rows 27001:28000: 12.68 sec elapsed
## loop 29, rows 28001:29000: 7.09 sec elapsed
## loop 30, rows 29001:30000: 7.56 sec elapsed
## loop 31, rows 30001:31000: 6.66 sec elapsed
## loop 32, rows 31001:32000: 10 sec elapsed
## loop 33, rows 32001:33000: 10.42 sec elapsed
## loop 34, rows 33001:34000: 8.59 sec elapsed
## loop 35, rows 34001:35000: 7.61 sec elapsed
## loop 36, rows 35001:36000: 8.1 sec elapsed
## loop 37, rows 36001:37000: 6.54 sec elapsed
## loop 38, rows 37001:38000: 8.5 sec elapsed
## loop 39, rows 38001:39000: 6.71 sec elapsed
## loop 40, rows 39001:40000: 7.42 sec elapsed
## loop 41, rows 40001:41000: 12.31 sec elapsed
## final loop, rows 41001:41861: 8.39 sec elapsed
## total: 315.11 sec elapsed</code></pre>
</div>
<div id="read-1-gene-at-a-time" class="section level1">
<h1>Read 1 gene at a time</h1>
<p>Now to define a function that opens the h5 file, reads the particular slice of data we want, and then close the h5 file. It is important to ensure the file gets closed, otherwise it can get corrupt. This is a bit of a drawback for this approach, but I have yet to encounter a problem so far.</p>
<pre class="r"><code>read_gene &lt;- function(gene, file_h5) {
  #tic(&#39;whole thing&#39;)
  stopifnot(file.exists(file_h5))
  # open connections
  #tic(&#39;open&#39;)
  h5 &lt;- H5File$new(
    file_h5, 
    mode = &quot;r&quot;)
  
  #on.exit(h5$close_all())
  
  h5_data &lt;- h5[[&#39;grp&#39;]][[&#39;data&#39;]]
  h5_rownames &lt;- h5[[&#39;grp&#39;]][[&#39;rownames&#39;]]
  h5_colnames &lt;- h5[[&#39;grp&#39;]][[&#39;colnames&#39;]]
  
  #toc()
  #tic(&#39;read gene&#39;)
  ind &lt;- str_which(h5_rownames[], gene)
  #ind &lt;- 18871
  #print(ind)
  gene &lt;- h5_data[ind,]
  #toc()
  
  #tic(&#39;set name&#39;)
  gene &lt;- setNames(gene, nm = h5_colnames[])
  #toc()
  
  #tic(&#39;close&#39;)
  h5$close_all()
  #toc()
  #toc()
  return(gene) 
}


gene &lt;- read_gene(&#39;AC006486.2&#39;, file_h5)</code></pre>
</div>
<div id="hdf5array" class="section level1">
<h1>HDF5array</h1>
<p>Bioconductor has the <a href="https://bioconductor.org/packages/release/bioc/html/HDF5Array.html"><code>HDF5array</code></a> R package that supports writing / loading dense and sparse matrices from <code>.h5</code> files.</p>
<p>Let’s see how this compares to the manual implementation.</p>
<p>First write to disk using <code>HDF5Array::writeHDF5Array</code></p>
<pre class="r"><code>file_h5array &lt;- fs::path(&#39;HDF5array.h5&#39;)
if (file.exists(file_h5array)) file.remove(file_h5array)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<pre class="r"><code>tic();HDF5Array::writeHDF5Array(
  DelayedArray(counts), 
  file_h5array, as.sparse = FALSE, name = &#39;full&#39;, with.dimnames = TRUE);toc()</code></pre>
<pre><code>## &lt;41861 x 173954&gt; HDF5Matrix object of type &quot;double&quot;:
##           bcIIOD bcHTNA bcDLAV ... bcELDH bcFGGM
##   5S_rRNA      0      0      0   .      0      0
## 5_8S_rRNA      0      0      0   .      0      0
##       7SK      0      0      0   .      0      0
##      A1BG      0      0      0   .      0      0
##  A1BG-AS1      0      0      0   .      0      0
##       ...      .      .      .   .      .      .
##   snoZ278      0      0      0   .      0      0
##    snoZ40      0      0      0   .      0      0
##     snoZ6      0      0      0   .      0      0
##  snosnR66      0      0      0   .      0      0
##    uc_338      0      0      0   .      0      0</code></pre>
<pre><code>## 466.64 sec elapsed</code></pre>
<pre class="r"><code>h5ls(file_h5array) # see content of h5</code></pre>
<pre><code>##             group           name       otype dclass            dim
## 0               / .full_dimnames   H5I_GROUP                      
## 1 /.full_dimnames              1 H5I_DATASET STRING          41861
## 2 /.full_dimnames              2 H5I_DATASET STRING         173954
## 3               /           full H5I_DATASET  FLOAT 41861 x 173954</code></pre>
<p>Point to the hf5 file</p>
<pre class="r"><code>hf5 &lt;- HDF5Array(file_h5array,  name = &#39;full&#39;, as.sparse = TRUE)
hf5[&#39;AC006486.2&#39;,] |&gt;  head()</code></pre>
<pre><code>## bcIIOD bcHTNA bcDLAV bcHNVA bcALZN bcEIYJ 
##      0      0      0      0      0      0</code></pre>
<p>Explore the class</p>
<pre class="r"><code>showtree(hf5)</code></pre>
<pre><code>## 41861x173954 double, sparse: HDF5Matrix object
## └─ 41861x173954 double, sparse: [seed] HDF5ArraySeed object</code></pre>
<pre class="r"><code>showtree(hf5[2,])</code></pre>
<pre><code>##  double: [seed] numeric object</code></pre>
<pre class="r"><code>class(hf5)</code></pre>
<pre><code>## [1] &quot;HDF5Matrix&quot;
## attr(,&quot;package&quot;)
## [1] &quot;HDF5Array&quot;</code></pre>
<pre class="r"><code>is(hf5, &#39;DelayedMatrix&#39;)</code></pre>
<pre><code>## [1] TRUE</code></pre>
</div>
<div id="compare-hdf5array-vs-diy-implementation" class="section level1">
<h1>Compare HDF5array vs diy implementation</h1>
<p>Now we have written the count matrices to disk in hdf5 format in two ways: manually, and through <code>HDF5Array</code>.</p>
<p>Let’s see if there are differences in performance in reading 1 gene at a time.</p>
<div id="memory-and-time" class="section level2">
<h2>Memory and time</h2>
<pre class="r"><code>bench_read &lt;- bench::mark(
  HDF5Array = hf5[&#39;AC006486.2&#39;,],
  `h5 - manual` = read_gene(&#39;AC006486.2&#39;, file_h5),
  `in-memory slice` = counts[&#39;AC006486.2&#39;,]
)  

summary(bench_read) |&gt; 
  mutate(expression = as.character(expression)) |&gt;  
  select(-memory, -result, -time, -gc) |&gt;  gt()</code></pre>
<div id="tknwdwsdpm" style="padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;">
<style>#tknwdwsdpm table {
  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#tknwdwsdpm thead, #tknwdwsdpm tbody, #tknwdwsdpm tfoot, #tknwdwsdpm tr, #tknwdwsdpm td, #tknwdwsdpm th {
  border-style: none;
}

#tknwdwsdpm p {
  margin: 0;
  padding: 0;
}

#tknwdwsdpm .gt_table {
  display: table;
  border-collapse: collapse;
  line-height: normal;
  margin-left: auto;
  margin-right: auto;
  color: #333333;
  font-size: 16px;
  font-weight: normal;
  font-style: normal;
  background-color: #FFFFFF;
  width: auto;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #A8A8A8;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #A8A8A8;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
}

#tknwdwsdpm .gt_caption {
  padding-top: 4px;
  padding-bottom: 4px;
}

#tknwdwsdpm .gt_title {
  color: #333333;
  font-size: 125%;
  font-weight: initial;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-color: #FFFFFF;
  border-bottom-width: 0;
}

#tknwdwsdpm .gt_subtitle {
  color: #333333;
  font-size: 85%;
  font-weight: initial;
  padding-top: 3px;
  padding-bottom: 5px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-color: #FFFFFF;
  border-top-width: 0;
}

#tknwdwsdpm .gt_heading {
  background-color: #FFFFFF;
  text-align: center;
  border-bottom-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#tknwdwsdpm .gt_bottom_border {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#tknwdwsdpm .gt_col_headings {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#tknwdwsdpm .gt_col_heading {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 6px;
  padding-left: 5px;
  padding-right: 5px;
  overflow-x: hidden;
}

#tknwdwsdpm .gt_column_spanner_outer {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 4px;
  padding-right: 4px;
}

#tknwdwsdpm .gt_column_spanner_outer:first-child {
  padding-left: 0;
}

#tknwdwsdpm .gt_column_spanner_outer:last-child {
  padding-right: 0;
}

#tknwdwsdpm .gt_column_spanner {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 5px;
  overflow-x: hidden;
  display: inline-block;
  width: 100%;
}

#tknwdwsdpm .gt_spanner_row {
  border-bottom-style: hidden;
}

#tknwdwsdpm .gt_group_heading {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  text-align: left;
}

#tknwdwsdpm .gt_empty_group_heading {
  padding: 0.5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: middle;
}

#tknwdwsdpm .gt_from_md > :first-child {
  margin-top: 0;
}

#tknwdwsdpm .gt_from_md > :last-child {
  margin-bottom: 0;
}

#tknwdwsdpm .gt_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  margin: 10px;
  border-top-style: solid;
  border-top-width: 1px;
  border-top-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  overflow-x: hidden;
}

#tknwdwsdpm .gt_stub {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
}

#tknwdwsdpm .gt_stub_row_group {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  vertical-align: top;
}

#tknwdwsdpm .gt_row_group_first td {
  border-top-width: 2px;
}

#tknwdwsdpm .gt_row_group_first th {
  border-top-width: 2px;
}

#tknwdwsdpm .gt_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#tknwdwsdpm .gt_first_summary_row {
  border-top-style: solid;
  border-top-color: #D3D3D3;
}

#tknwdwsdpm .gt_first_summary_row.thick {
  border-top-width: 2px;
}

#tknwdwsdpm .gt_last_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#tknwdwsdpm .gt_grand_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#tknwdwsdpm .gt_first_grand_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: double;
  border-top-width: 6px;
  border-top-color: #D3D3D3;
}

#tknwdwsdpm .gt_last_grand_summary_row_top {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: double;
  border-bottom-width: 6px;
  border-bottom-color: #D3D3D3;
}

#tknwdwsdpm .gt_striped {
  background-color: rgba(128, 128, 128, 0.05);
}

#tknwdwsdpm .gt_table_body {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#tknwdwsdpm .gt_footnotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#tknwdwsdpm .gt_footnote {
  margin: 0px;
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#tknwdwsdpm .gt_sourcenotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#tknwdwsdpm .gt_sourcenote {
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#tknwdwsdpm .gt_left {
  text-align: left;
}

#tknwdwsdpm .gt_center {
  text-align: center;
}

#tknwdwsdpm .gt_right {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

#tknwdwsdpm .gt_font_normal {
  font-weight: normal;
}

#tknwdwsdpm .gt_font_bold {
  font-weight: bold;
}

#tknwdwsdpm .gt_font_italic {
  font-style: italic;
}

#tknwdwsdpm .gt_super {
  font-size: 65%;
}

#tknwdwsdpm .gt_footnote_marks {
  font-size: 75%;
  vertical-align: 0.4em;
  position: initial;
}

#tknwdwsdpm .gt_asterisk {
  font-size: 100%;
  vertical-align: 0;
}

#tknwdwsdpm .gt_indent_1 {
  text-indent: 5px;
}

#tknwdwsdpm .gt_indent_2 {
  text-indent: 10px;
}

#tknwdwsdpm .gt_indent_3 {
  text-indent: 15px;
}

#tknwdwsdpm .gt_indent_4 {
  text-indent: 20px;
}

#tknwdwsdpm .gt_indent_5 {
  text-indent: 25px;
}
</style>
<table class="gt_table" data-quarto-disable-processing="false" data-quarto-bootstrap="false">
  <thead>
    <tr class="gt_col_headings">
      <th class="gt_col_heading gt_columns_bottom_border gt_left" rowspan="1" colspan="1" scope="col" id="expression">expression</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_center" rowspan="1" colspan="1" scope="col" id="min">min</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_center" rowspan="1" colspan="1" scope="col" id="median">median</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="itr/sec">itr/sec</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_center" rowspan="1" colspan="1" scope="col" id="mem_alloc">mem_alloc</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="gc/sec">gc/sec</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="n_itr">n_itr</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="n_gc">n_gc</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_center" rowspan="1" colspan="1" scope="col" id="total_time">total_time</th>
    </tr>
  </thead>
  <tbody class="gt_table_body">
    <tr><td headers="expression" class="gt_row gt_left">HDF5Array</td>
<td headers="min" class="gt_row gt_center">1.7s</td>
<td headers="median" class="gt_row gt_center">1.7s</td>
<td headers="itr/sec" class="gt_row gt_right">0.5875962</td>
<td headers="mem_alloc" class="gt_row gt_center">10.11MB</td>
<td headers="gc/sec" class="gt_row gt_right">0</td>
<td headers="n_itr" class="gt_row gt_right">1</td>
<td headers="n_gc" class="gt_row gt_right">0</td>
<td headers="total_time" class="gt_row gt_center">1.7s</td></tr>
    <tr><td headers="expression" class="gt_row gt_left">h5 - manual</td>
<td headers="min" class="gt_row gt_center">774.7ms</td>
<td headers="median" class="gt_row gt_center">774.7ms</td>
<td headers="itr/sec" class="gt_row gt_right">1.2908001</td>
<td headers="mem_alloc" class="gt_row gt_center">4.97MB</td>
<td headers="gc/sec" class="gt_row gt_right">0</td>
<td headers="n_itr" class="gt_row gt_right">1</td>
<td headers="n_gc" class="gt_row gt_right">0</td>
<td headers="total_time" class="gt_row gt_center">774.7ms</td></tr>
    <tr><td headers="expression" class="gt_row gt_left">in-memory slice</td>
<td headers="min" class="gt_row gt_center">154.5ms</td>
<td headers="median" class="gt_row gt_center">210.9ms</td>
<td headers="itr/sec" class="gt_row gt_right">5.0724987</td>
<td headers="mem_alloc" class="gt_row gt_center">3.93MB</td>
<td headers="gc/sec" class="gt_row gt_right">0</td>
<td headers="n_itr" class="gt_row gt_right">3</td>
<td headers="n_gc" class="gt_row gt_right">0</td>
<td headers="total_time" class="gt_row gt_center">591.4ms</td></tr>
  </tbody>
  
  
</table>
</div>
<pre class="r"><code>bench_read |&gt;  autoplot(type = &#39;jitter&#39;)</code></pre>
<p><img src="{{< blogdown/postref >}}index.en_files/figure-html/bench-1.png" width="672" /></p>
<p><code>HDF5array</code> is ~2x slower than <code>ShinyCell</code>’s manual method</p>
<p><code>ShinyCell</code> approach is almost as fast as holding in memory, without of course the cost is occupying a large amount of memory at any given time.</p>
</div>
<div id="on-disk-space" class="section level2">
<h2>on-disk space</h2>
<pre class="r"><code>data.frame(file = c(file_h5, file_h5array)) |&gt; 
  mutate(file_size = fs::file_size(file)) </code></pre>
<pre><code>##           file file_size
## 1    counts.h5   153.28M
## 2 HDF5array.h5   221.88M</code></pre>
</div>
</div>
<div id="singlecellexperiment" class="section level1">
<h1>SingleCellExperiment</h1>
<p>In reading <code>HD5Array</code> docs, I learned that you can back a <code>SingleCellExperiment</code> object with a HDF5-backed matrix. This is actually incredibly useful, because now we can use any packages for <code>SingleCellExperiment</code> (like <a href="https://stemangiola.github.io/tidySingleCellExperiment/"><code>tidySingleCellExperiment</code></a>).</p>
<pre class="r"><code>sce_h5 &lt;- SingleCellExperiment(assays = list(counts = hf5))</code></pre>
<p>Size of SingleCellExperiment object backed by HDF5</p>
<pre class="r"><code>object.size(sce_h5) |&gt;  print(units = &#39;auto&#39;)</code></pre>
<pre><code>## 9.1 Mb</code></pre>
<p>Size of dgc counts matrix held in memory</p>
<pre class="r"><code>object.size(counts) |&gt;  print(units = &#39;auto&#39;)</code></pre>
<pre><code>## 624.4 Mb</code></pre>
<p>Speed:</p>
<pre class="r"><code>bench::mark(sce_h5[&#39;AC006486.2&#39;,]) |&gt; select(-c(result:gc)) |&gt;  gt()</code></pre>
<div id="fzgpsnstab" style="padding-left:0px;padding-right:0px;padding-top:10px;padding-bottom:10px;overflow-x:auto;overflow-y:auto;width:auto;height:auto;">
<style>#fzgpsnstab table {
  font-family: system-ui, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

#fzgpsnstab thead, #fzgpsnstab tbody, #fzgpsnstab tfoot, #fzgpsnstab tr, #fzgpsnstab td, #fzgpsnstab th {
  border-style: none;
}

#fzgpsnstab p {
  margin: 0;
  padding: 0;
}

#fzgpsnstab .gt_table {
  display: table;
  border-collapse: collapse;
  line-height: normal;
  margin-left: auto;
  margin-right: auto;
  color: #333333;
  font-size: 16px;
  font-weight: normal;
  font-style: normal;
  background-color: #FFFFFF;
  width: auto;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #A8A8A8;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #A8A8A8;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
}

#fzgpsnstab .gt_caption {
  padding-top: 4px;
  padding-bottom: 4px;
}

#fzgpsnstab .gt_title {
  color: #333333;
  font-size: 125%;
  font-weight: initial;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-color: #FFFFFF;
  border-bottom-width: 0;
}

#fzgpsnstab .gt_subtitle {
  color: #333333;
  font-size: 85%;
  font-weight: initial;
  padding-top: 3px;
  padding-bottom: 5px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-color: #FFFFFF;
  border-top-width: 0;
}

#fzgpsnstab .gt_heading {
  background-color: #FFFFFF;
  text-align: center;
  border-bottom-color: #FFFFFF;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#fzgpsnstab .gt_bottom_border {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#fzgpsnstab .gt_col_headings {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
}

#fzgpsnstab .gt_col_heading {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 6px;
  padding-left: 5px;
  padding-right: 5px;
  overflow-x: hidden;
}

#fzgpsnstab .gt_column_spanner_outer {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: normal;
  text-transform: inherit;
  padding-top: 0;
  padding-bottom: 0;
  padding-left: 4px;
  padding-right: 4px;
}

#fzgpsnstab .gt_column_spanner_outer:first-child {
  padding-left: 0;
}

#fzgpsnstab .gt_column_spanner_outer:last-child {
  padding-right: 0;
}

#fzgpsnstab .gt_column_spanner {
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: bottom;
  padding-top: 5px;
  padding-bottom: 5px;
  overflow-x: hidden;
  display: inline-block;
  width: 100%;
}

#fzgpsnstab .gt_spanner_row {
  border-bottom-style: hidden;
}

#fzgpsnstab .gt_group_heading {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  text-align: left;
}

#fzgpsnstab .gt_empty_group_heading {
  padding: 0.5px;
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  vertical-align: middle;
}

#fzgpsnstab .gt_from_md > :first-child {
  margin-top: 0;
}

#fzgpsnstab .gt_from_md > :last-child {
  margin-bottom: 0;
}

#fzgpsnstab .gt_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  margin: 10px;
  border-top-style: solid;
  border-top-width: 1px;
  border-top-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 1px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 1px;
  border-right-color: #D3D3D3;
  vertical-align: middle;
  overflow-x: hidden;
}

#fzgpsnstab .gt_stub {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
}

#fzgpsnstab .gt_stub_row_group {
  color: #333333;
  background-color: #FFFFFF;
  font-size: 100%;
  font-weight: initial;
  text-transform: inherit;
  border-right-style: solid;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
  padding-left: 5px;
  padding-right: 5px;
  vertical-align: top;
}

#fzgpsnstab .gt_row_group_first td {
  border-top-width: 2px;
}

#fzgpsnstab .gt_row_group_first th {
  border-top-width: 2px;
}

#fzgpsnstab .gt_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#fzgpsnstab .gt_first_summary_row {
  border-top-style: solid;
  border-top-color: #D3D3D3;
}

#fzgpsnstab .gt_first_summary_row.thick {
  border-top-width: 2px;
}

#fzgpsnstab .gt_last_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#fzgpsnstab .gt_grand_summary_row {
  color: #333333;
  background-color: #FFFFFF;
  text-transform: inherit;
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
}

#fzgpsnstab .gt_first_grand_summary_row {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-top-style: double;
  border-top-width: 6px;
  border-top-color: #D3D3D3;
}

#fzgpsnstab .gt_last_grand_summary_row_top {
  padding-top: 8px;
  padding-bottom: 8px;
  padding-left: 5px;
  padding-right: 5px;
  border-bottom-style: double;
  border-bottom-width: 6px;
  border-bottom-color: #D3D3D3;
}

#fzgpsnstab .gt_striped {
  background-color: rgba(128, 128, 128, 0.05);
}

#fzgpsnstab .gt_table_body {
  border-top-style: solid;
  border-top-width: 2px;
  border-top-color: #D3D3D3;
  border-bottom-style: solid;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
}

#fzgpsnstab .gt_footnotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#fzgpsnstab .gt_footnote {
  margin: 0px;
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#fzgpsnstab .gt_sourcenotes {
  color: #333333;
  background-color: #FFFFFF;
  border-bottom-style: none;
  border-bottom-width: 2px;
  border-bottom-color: #D3D3D3;
  border-left-style: none;
  border-left-width: 2px;
  border-left-color: #D3D3D3;
  border-right-style: none;
  border-right-width: 2px;
  border-right-color: #D3D3D3;
}

#fzgpsnstab .gt_sourcenote {
  font-size: 90%;
  padding-top: 4px;
  padding-bottom: 4px;
  padding-left: 5px;
  padding-right: 5px;
}

#fzgpsnstab .gt_left {
  text-align: left;
}

#fzgpsnstab .gt_center {
  text-align: center;
}

#fzgpsnstab .gt_right {
  text-align: right;
  font-variant-numeric: tabular-nums;
}

#fzgpsnstab .gt_font_normal {
  font-weight: normal;
}

#fzgpsnstab .gt_font_bold {
  font-weight: bold;
}

#fzgpsnstab .gt_font_italic {
  font-style: italic;
}

#fzgpsnstab .gt_super {
  font-size: 65%;
}

#fzgpsnstab .gt_footnote_marks {
  font-size: 75%;
  vertical-align: 0.4em;
  position: initial;
}

#fzgpsnstab .gt_asterisk {
  font-size: 100%;
  vertical-align: 0;
}

#fzgpsnstab .gt_indent_1 {
  text-indent: 5px;
}

#fzgpsnstab .gt_indent_2 {
  text-indent: 10px;
}

#fzgpsnstab .gt_indent_3 {
  text-indent: 15px;
}

#fzgpsnstab .gt_indent_4 {
  text-indent: 20px;
}

#fzgpsnstab .gt_indent_5 {
  text-indent: 25px;
}
</style>
<table class="gt_table" data-quarto-disable-processing="false" data-quarto-bootstrap="false">
  <thead>
    <tr class="gt_col_headings">
      <th class="gt_col_heading gt_columns_bottom_border gt_center" rowspan="1" colspan="1" scope="col" id="expression">expression</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_center" rowspan="1" colspan="1" scope="col" id="min">min</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_center" rowspan="1" colspan="1" scope="col" id="median">median</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="itr/sec">itr/sec</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_center" rowspan="1" colspan="1" scope="col" id="mem_alloc">mem_alloc</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="gc/sec">gc/sec</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="n_itr">n_itr</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_right" rowspan="1" colspan="1" scope="col" id="n_gc">n_gc</th>
      <th class="gt_col_heading gt_columns_bottom_border gt_center" rowspan="1" colspan="1" scope="col" id="total_time">total_time</th>
    </tr>
  </thead>
  <tbody class="gt_table_body">
    <tr><td headers="expression" class="gt_row gt_center">[, sce_h5, AC006486.2, </td>
<td headers="min" class="gt_row gt_center">81.4ms</td>
<td headers="median" class="gt_row gt_center">83.5ms</td>
<td headers="itr/sec" class="gt_row gt_right">11.77477</td>
<td headers="mem_alloc" class="gt_row gt_center">7.49MB</td>
<td headers="gc/sec" class="gt_row gt_right">0</td>
<td headers="n_itr" class="gt_row gt_right">6</td>
<td headers="n_gc" class="gt_row gt_right">0</td>
<td headers="total_time" class="gt_row gt_center">510ms</td></tr>
  </tbody>
  
  
</table>
</div>
</div>
<div id="conclusion" class="section level1">
<h1>Conclusion</h1>
<ul>
<li><code>HDF5</code> format is great for memory efficient loading of single cell data, particularly for single gene queries which take less than 1 second on a 200,000 cell dataset.</li>
<li>The manual <code>shinyCell</code> h5 method is almost twice as fast as <code>HDF5Array</code> (~1 second vs 0.5 second)</li>
<li>but <code>SingleCellExperiment</code> can carry hdf5-backed count matrices with <code>HDF5Array</code>, making it more useful as it opens usage to other single cell tools</li>
<li>The majority of time reading from <code>HDF5</code> is actually closing the connection of the file.</li>
</ul>
</div>
